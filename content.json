{"meta":{"title":"KevinWu's blog","subtitle":"No pains, No gains","description":"Hello","author":"Kevin Wu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2016-07-07T12:52:07.000Z","updated":"2016-07-07T12:52:07.000Z","comments":true,"path":"2016/07/07/hello-world/","link":"","permalink":"http://yoursite.com/2016/07/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"如何写轻量的ViewController","slug":"如何写轻量的ViewController","date":"2016-06-02T13:50:33.000Z","updated":"2016-07-07T14:09:20.000Z","comments":true,"path":"2016/06/02/如何写轻量的ViewController/","link":"","permalink":"http://yoursite.com/2016/06/02/如何写轻量的ViewController/","excerpt":"前言 View controllers 通常是 iOS 项目中最大的文件，因为它们包含了许多不必要的代码。所以 View controllers 中的代码几乎总是复用率较低，并且随着业务的不断增长，ViewController也将越来越庞大，所以是时候谈谈该如何为ViewController瘦身了。","text":"前言 View controllers 通常是 iOS 项目中最大的文件，因为它们包含了许多不必要的代码。所以 View controllers 中的代码几乎总是复用率较低，并且随着业务的不断增长，ViewController也将越来越庞大，所以是时候谈谈该如何为ViewController瘦身了。 理想的ViewController职责 在初始化时，构造相应的 View 和 Model。 监听 Model 层的事件，将 Model 层的数据传递到 View 层。 监听 View 层的事件，并且将 View 层的事件转发到 Model 层。 之所以说ViewController里面有许多不必要的代码原因有如下几点: 根本没有创建页面的model类，而是把所有的代码都放在ViewController里面，例如把数据的请求直接放在ViewController里面。 业务层抽离不够彻底或者说找不到合适的方法去把业务逻辑与ViewController分开。 代码复用性差，其实做到复用性高很难。 页面业务逻辑确实太多，因为即使处理业务逻辑都放在其他类里面，你也需要开放接口放到ViewController里面，过多的接口也必然会加重ViewController。 如何对ViewController瘦身？把TableView的Data Source分离出来 把 UITableViewDataSource 的代码提取出来放到一个单独的类中，是为 view controller 瘦身的强大技术之一。如果你能多做几次，你就能总结出一些模式，并且创建出可复用的类。 举个例子：有个 PhotosViewController 类，它有以下几个方法： 123456789101112131415 # pragma mark DataSource- (NSInteger)tableView:(UITableView*)tableView numberOfRowsInSection:(NSInteger)section &#123; return photos.count;&#125;- (UITableViewCell*)tableView:(UITableView*)tableView cellForRowAtIndexPath:(NSIndexPath*)indexPath &#123; PhotoCell* cell = [tableView dequeueReusableCellWithIdentifier:PhotoCellIdentifier forIndexPath:indexPath]; Photo* photo = photos[indexPath.row]; cell.label.text = photo.name; return cell;&#125; 这些代码基本都是围绕数组做一些事情，更针对地说，是围绕 view controller 所管理的 photos 数组做一些事情。我们可以尝试把数组相关的代码移到单独的类中。我们使用一个 block 来设置 cell，主要代码如下：1234567891011121314151617181920 @implementation ArrayDataSource- (id)itemAtIndexPath:(NSIndexPath*)indexPath &#123; return items[(NSUInteger)indexPath.row];&#125;- (NSInteger)tableView:(UITableView*)tableView numberOfRowsInSection:(NSInteger)section &#123; return items.count;&#125;- (UITableViewCell*)tableView:(UITableView*)tableView cellForRowAtIndexPath:(NSIndexPath*)indexPath &#123; id cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier forIndexPath:indexPath]; id item = [self itemAtIndexPath:indexPath]; configureCellBlock(cell,item); return cell;&#125;@end 现在，你可以把 view controller 中的这 3 个方法去掉了，取而代之，你可以创建一个 ArrayDataSource 类的实例作为 table view 的 data source。1234567 void (^configureCell)(PhotoCell*, Photo*) = ^(PhotoCell* cell, Photo* photo) &#123; cell.label.text = photo.name;&#125;;photosArrayDataSource = [[ArrayDataSource alloc] initWithItems:photos cellIdentifier:PhotoCellIdentifier configureCellBlock:configureCell];self.tableView.dataSource = photosArrayDataSource; 我们可以看出DataSource类里面要穿的参数就是一个数组，一个ReuseIdentifier以及一个block，里面不涉及其它类，所以可以完全可以复用于其它ViewController。 构造ViewModel我们看一个简单的 Person Model 以及相应的 View Controller：12345678910@interface Person : NSObject- (instancetype)initwithSalutation:(NSString *)salutation firstName:(NSString *)firstName lastName:(NSString *)lastName birthdate:(NSDate *)birthdate;@property (nonatomic, readonly) NSString *salutation;@property (nonatomic, readonly) NSString *firstName;@property (nonatomic, readonly) NSString *lastName;@property (nonatomic, readonly) NSDate *birthdate;@end 假设我们有一个 PersonViewController ，在 viewDidLoad 里，只需要基于它的 model 属性设置一些 Label 即可。如下所示：12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; if (self.model.salutation.length &gt; 0) &#123; self.nameLabel.text = [NSString stringWithFormat:@\"%@ %@ %@\", self.model.salutation, self.model.firstName, self.model.lastName]; &#125; else &#123; self.nameLabel.text = [NSString stringWithFormat:@\"%@ %@\", self.model.firstName, self.model.lastName]; &#125; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@\"EEEE MMMM d, yyyy\"]; self.birthdateLabel.text = [dateFormatter stringFromDate:model.birthdate];&#125; 现在看看我们构造一个View Model来增强它从而达到瘦身ViewController的目的。12345678910@interface PersonViewModel : NSObject- (instancetype)initWithPerson:(Person *)person;@property (nonatomic, readonly) Person *person;@property (nonatomic, readonly) NSString *nameText;@property (nonatomic, readonly) NSString *birthdateText;@end ViewModel的实现大概如下：123456789101112131415161718192021@implementation PersonViewModel- (instancetype)initWithPerson:(Person *)person &#123; self = [super init]; if (!self) return nil; _person = person; if (person.salutation.length &gt; 0) &#123; _nameText = [NSString stringWithFormat:@\"%@ %@ %@\", self.person.salutation, self.person.firstName, self.person.lastName]; &#125; else &#123; _nameText = [NSString stringWithFormat:@\"%@ %@\", self.person.firstName, self.person.lastName]; &#125; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@\"EEEE MMMM d, yyyy\"]; _birthdateText = [dateFormatter stringFromDate:person.birthdate]; return self;&#125;@end 将业务逻辑移到Model中假如下面是 viewController中的一块代码，用来查找一个用户的目前的优先事项的列表1234567- (void)loadPriorities &#123; NSDate* now = [NSDate date]; NSString* formatString = @\"startDate = %@\"; NSPredicate* predicate = [NSPredicate predicateWithFormat:formatString, now, now]; NSSet* priorities = [self.user.priorities filteredSetUsingPredicate:predicate]; self.priorities = [priorities allObjects];&#125; 那如果我们能把这些代码移动到 User 类或者其category 中，那将会变得更加清晰，处理之后，在 View Controller.m 中看起来就是这样：123- (void)loadPriorities &#123; self.priorities = [user currentPriorities];&#125; 在user类中实现如下：123456- (NSArray*)currentPriorities &#123; NSDate* now = [NSDate date]; NSString* formatString = @\"startDate = %@\"; NSPredicate* predicate = [NSPredicate predicateWithFormat:formatString, now, now]; return [[self.priorities filteredSetUsingPredicate:predicate] allObjects];&#125; 把网络请求逻辑移到Model层下面这段代码是我遇到一个页面网络请求数据的方法，因为业务逻辑和中间层不能完美的原因，导致客户端不得不做很多数据处理的逻辑，所以导致这个网络请求方法大的惨不忍睹，如果将此方法直接放在viewController里面，那就更惨不忍睹了。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778- (void)fetchJourneyListWithSuccessBlock:(JASuccessBlock)successBlock failBlock:(JAFailBlock)failBlock&#123; __weak typeof(self) weakSelf = self; self.requestList.memberId = JA_MEMBERID; [self.requestList startWithSuccessBlock:^(ResponseGetScheduleOrderList *response, NSDictionary *options) &#123; weakSelf.canDelete = [response.isOpenDel isEqualToString:@\"1\"]; weakSelf.isShowAddBtn = [response.isOpenEdit isEqualToString:@\"1\"]; weakSelf.isEnterPlanJourney = [response.versionType isEqualToString:@\"0\"]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSMutableArray&lt;__kindof NSArray *&gt; *arrayJourneyListNew = [NSMutableArray array]; NSMutableArray&lt;JADateData *&gt; *arrayDateListNew = [NSMutableArray array]; NSArray&lt;JAJourneyData *&gt; *arrayJourneyList = response.orderList; NSArray&lt;JADateData *&gt; *arrayJourneyDate = response.journeyDateList; NSMutableDictionary *dictDate = [NSMutableDictionary dictionary]; [arrayJourneyDate enumerateObjectsUsingBlock:^(JADateData * _Nonnull item, NSUInteger idx, BOOL * _Nonnull stop) &#123; if (item.journeyDate.length) &#123; dictDate[item.journeyDate] = @(idx); if (!item.journeyDateDisplay || item.journeyDateDisplay.length == 0) &#123; NSDate *date = [TCDateFormatter stringToDateCustom:item.journeyDate formatString:def_YearMonthDay_DF]; if (date) &#123; item.journeyDateDisplay = [TCDateFormatter dateToStringCustom:date formatString:def_MonthDayWeekTwoChn_DF]; &#125; &#125; [arrayDateListNew addObject:item]; [arrayJourneyListNew addObject:[NSMutableArray array]]; &#125; &#125;]; NSMutableArray&lt;JAFlightData *&gt; *arrayFlight = [NSMutableArray&lt;JAFlightData *&gt; array]; [arrayJourneyList enumerateObjectsUsingBlock:^(JAJourneyData * _Nonnull item, NSUInteger idx, BOOL * _Nonnull stop) &#123; if (item.journeyDate.length &gt; 0) &#123; item.qrNumberUrl = response.qrNumberUrl; NSNumber *nIndex = dictDate[item.journeyDate]; if (!nIndex) return; NSUInteger index = nIndex.integerValue; if (index &gt;= arrayJourneyListNew.count) return; [item configureWithIndex:idx]; NSMutableArray *array = arrayJourneyListNew[index]; [array addObject:item]; &#125; if ([item.projectTag isEqualToString:TCTProjectTagFlightInternal] &amp;&amp; item.specialData) &#123; [arrayFlight addObject:[item.specialData copy]]; &#125;else if ([item.projectTag isEqualToString:kRecordJourneyProjectTag] || [item.projectTag isEqualToString:kPlanJourneyProjectTag]) &#123; iCustomProjectNumber ++; &#125;else if([item.projectTag isEqualToString:kClassicJourneyProjectTag])&#123; iClassicProjectNumber ++; &#125;else if ([item.createSource isEqualToString:@\"1\"] &amp;&amp; item.poiType.length &gt; 0) &#123; iPoiProjectNumber ++; &#125;else if ([item.createSource isEqualToString:@\"2\"]) &#123; iShareProjectNumber ++; &#125; &#125;]; dispatch_async(dispatch_get_main_queue(), ^&#123; weakSelf.journeyList = arrayJourneyListNew; weakSelf.dateList = arrayDateListNew; weakSelf.specialData = arrayFlight; [weakSelf refreshJourneyListWithFlightDataDictionary]; !successBlock ?: successBlock(weakSelf.dateList.count == 0); [weakSelf refreshAllCache]; &#125;); &#125;); &#125; failBlock:^(TCTNetworkError *error, NSDictionary *options) &#123; ResponseGetScheduleOrderList *response = error.rspObject; weakSelf.isShowAddBtn = [response.isOpenEdit isEqualToString:@\"1\"]; weakSelf.isEnterPlanJourney = [response.versionType isEqualToString:@\"0\"]; BOOL isNoNetwork = (error.code == TCTErrorNetworkCallbackUnReachable || error.code == TCTErrorNetworkCallbackFailWithServer || error.code == TCTErrorNetworkResponseValidFail); if (!isNoNetwork) &#123; [weakSelf removeAllCache]; weakSelf.journeyList = nil; weakSelf.dateList = nil; &#125; !failBlock ?: failBlock(error, options); &#125;];&#125; 把View代码移到View层不应该在 view controller 中构建复杂的 view 层次结构。你可以使用 Interface Builder 或者把 views 封装到一个 UIView 子类当中。例如，如果你要创建一个选择日期的控件，把它放到一个名为 DatePickerView 的类中会比把所有的事情都在 view controller 中做好好得多。再一次，这样增加了可复用性并保持了简单。不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。 小结通过代码的抽取，我们可以将原本的 MVC 设计模式中的 ViewController 进一步拆分，构造出网络请求层、ViewModel层，View层等其它类，来配合 Controller 工作，从而使 Controller 更加简单，我们的 App 更容易维护。 另外，不知道大家注意到没，其实 Controller 层是非常难于测试的，如果我们能够将 Controller 瘦身，就可以更方便地写 Unit Test 来测试各种与界面的无关的逻辑。虽然说移动端自动化测试框架都不太成熟，但是将 Controller 的代码抽取出来，是有助于我们后续做测试工作。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"lighter","slug":"lighter","permalink":"http://yoursite.com/tags/lighter/"}]}]}